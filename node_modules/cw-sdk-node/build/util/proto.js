"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const proto_1 = require("../modules/proto");
const helpers_1 = require("./helpers");
const logger_1 = require("./logger");
const orderSides = {
    0: "sell",
    1: "buy"
};
const orderSideToProto = {
    sell: 0,
    buy: 1
};
const fundingTypes = {
    0: "spot",
    1: "margin"
};
const fundingTypeToProto = {
    spot: 0,
    margin: 1
};
const orderTypes = {
    0: "market",
    1: "limit"
    // 2: "stoploss",
    // 3: "stoplosslimit",
    // 4: "takeprofit",
    // 5: "takeprofitlimit",
    // 6: "stoplosstakeprofit",
    // 7: "stoplosstakeprofitlimit",
    // 8: "trailingstoploss",
    // 9: "trailingstoplosslimit",
    // 10: "stoplossandlimit",
    // 11: "fillorkill",
    // 12: "settleposition"
};
const orderTypeToProto = {
    market: 0,
    limit: 1
    // stoploss: 2,
    // stoplosslimit: 3,
    // takeprofit: 4,
    // takeprofitlimit: 5,
    // stoplosstakeprofit: 6,
    // stoplosstakeprofitlimit: 7,
    // trailingstoploss: 8,
    // trailingstoplosslimit: 9,
    // stoplossandlimit: 10,
    // fillorkill: 11,
    // settleposition: 12
};
var Period;
(function (Period) {
    Period[Period["Period1M"] = 60] = "Period1M";
    Period[Period["Period3M"] = 180] = "Period3M";
    Period[Period["Period5M"] = 300] = "Period5M";
    Period[Period["Period15M"] = 900] = "Period15M";
    Period[Period["Period30M"] = 1800] = "Period30M";
    Period[Period["Period1H"] = 3600] = "Period1H";
    Period[Period["Period2H"] = 7200] = "Period2H";
    Period[Period["Period4H"] = 14400] = "Period4H";
    Period[Period["Period6H"] = 21600] = "Period6H";
    Period[Period["Period12H"] = 43200] = "Period12H";
    Period[Period["Period1D"] = 86400] = "Period1D";
    Period[Period["Period3D"] = 259200] = "Period3D";
    Period[Period["Period1W"] = 604800] = "Period1W";
})(Period || (Period = {}));
const periodFromInt = {
    60: Period.Period1M,
    180: Period.Period3M,
    300: Period.Period5M,
    900: Period.Period15M,
    1800: Period.Period30M,
    3600: Period.Period1H,
    7200: Period.Period2H,
    14400: Period.Period4H,
    21600: Period.Period6H,
    43200: Period.Period12H,
    86400: Period.Period1D,
    259200: Period.Period3D,
    604800: Period.Period1W
};
function privateOrderFromProto(privateOrder) {
    if (!privateOrder.priceParams ||
        !privateOrder.amountParamString ||
        typeof privateOrder.side !== "number" ||
        typeof privateOrder.type !== "number" ||
        typeof orderSides[privateOrder.side] !== "string" ||
        typeof orderTypes[privateOrder.type] !== "string") {
        logger_1.default.error("failed to parse private order %o", privateOrder);
        return null;
    }
    const priceParams = [];
    privateOrder.priceParams.forEach(p => {
        if (!p.valueString) {
            return;
        }
        if (!p.type) {
            p.type = proto_1.ProtobufBroker.PrivateOrder.PriceParamType.AbsoluteValue;
        }
        priceParams.push({
            value: p.valueString,
            type: p.type
        });
    });
    if (priceParams.length === 0) {
        logger_1.default.error("parsing private order failed; no price params %o", privateOrder);
        return null;
    }
    if (privateOrder.amountFilledString === "") {
        privateOrder.amountFilledString = "0.0";
    }
    let fundingType = "spot";
    if (typeof privateOrder.fundingType === "number") {
        fundingType = fundingTypes[privateOrder.fundingType];
    }
    let id;
    if (typeof privateOrder.id === "string" && privateOrder.id.length > 0) {
        id = privateOrder.id;
    }
    let timestamp;
    if (typeof privateOrder.time === "number" && privateOrder.time > 0) {
        timestamp = helpers_1.getDateFromSecs(privateOrder.time);
    }
    let expireTime;
    if (typeof privateOrder.expireTime === "number" &&
        privateOrder.expireTime > 0) {
        expireTime = helpers_1.getDateFromSecs(privateOrder.expireTime);
    }
    let leverage;
    if (privateOrder.leverage) {
        leverage = privateOrder.leverage;
    }
    let currentStop;
    if (privateOrder.currentStopString) {
        currentStop = privateOrder.currentStopString;
    }
    let initialStop;
    if (privateOrder.initialStopString) {
        initialStop = privateOrder.initialStopString;
    }
    let amountFilled;
    if (privateOrder.amountFilledString) {
        amountFilled = privateOrder.amountFilledString;
    }
    return {
        priceParams,
        amount: privateOrder.amountParamString,
        side: orderSides[privateOrder.side],
        type: orderTypes[privateOrder.type],
        fundingType,
        id,
        timestamp,
        expireTime,
        leverage,
        currentStop,
        initialStop,
        amountFilled
    };
}
function pairUpdateFromProto(pairUpdate) {
    if (!pairUpdate || !pairUpdate.pair) {
        return null;
    }
    const pair = {
        id: helpers_1.getString(pairUpdate.pair)
    };
    if (pairUpdate.vwapUpdate &&
        pairUpdate.vwapUpdate.vwap &&
        pairUpdate.vwapUpdate.timestamp) {
        const vwapUpdate = {
            vwap: String(pairUpdate.vwapUpdate.vwap),
            timestamp: helpers_1.getDateFromSecs(pairUpdate.vwapUpdate.timestamp)
        };
        return {
            pair,
            vwapUpdate
        };
    }
    if (pairUpdate.performanceUpdate &&
        pairUpdate.performanceUpdate.window &&
        pairUpdate.performanceUpdate.performance) {
        const performanceUpdate = {
            window: pairUpdate.performanceUpdate.window,
            performance: String(pairUpdate.performanceUpdate.performance)
        };
        return {
            pair,
            performanceUpdate
        };
    }
    if (pairUpdate.trendlineUpdate &&
        pairUpdate.trendlineUpdate.window &&
        pairUpdate.trendlineUpdate.time &&
        pairUpdate.trendlineUpdate.price &&
        pairUpdate.trendlineUpdate.volume) {
        const trendlineUpdate = {
            window: pairUpdate.trendlineUpdate.window,
            timestamp: helpers_1.getDateFromSecs(pairUpdate.trendlineUpdate.time),
            price: pairUpdate.trendlineUpdate.price,
            volume: pairUpdate.trendlineUpdate.volume
        };
        return {
            pair,
            trendlineUpdate
        };
    }
    return null;
}
function marketUpdateFromProto(marketUpdate) {
    if (!marketUpdate.market) {
        return null;
    }
    const market = marketFromProto(marketUpdate.market);
    if (!market) {
        return null;
    }
    if (marketUpdate.orderBookUpdate) {
        const orderBookSnapshot = orderBookSnapshotFromProto(marketUpdate.orderBookUpdate);
        if (orderBookSnapshot) {
            return {
                market,
                orderBookSnapshot
            };
        }
    }
    if (marketUpdate.orderBookDeltaUpdate) {
        const orderBookDelta = orderBookDeltaFromProto(marketUpdate.orderBookDeltaUpdate);
        if (orderBookDelta) {
            return {
                market,
                orderBookDelta
            };
        }
    }
    if (marketUpdate.orderBookSpreadUpdate) {
        const orderBookSpread = orderBookSpreadFromProto(marketUpdate.orderBookSpreadUpdate);
        if (orderBookSpread) {
            return {
                market,
                orderBookSpread
            };
        }
    }
    if (marketUpdate.tradesUpdate) {
        const trades = publicTradesFromProto(marketUpdate.tradesUpdate);
        if (trades) {
            return {
                market,
                trades
            };
        }
    }
    if (marketUpdate.intervalsUpdate) {
        const intervals = intervalsFromProto(marketUpdate.intervalsUpdate);
        if (intervals) {
            return {
                market,
                intervals
            };
        }
    }
    if (marketUpdate.summaryUpdate) {
        const summary = summaryFromProto(marketUpdate.summaryUpdate);
        if (summary) {
            return {
                market,
                summary
            };
        }
    }
    if (marketUpdate.sparklineUpdate) {
        const sparkline = sparklineFromProto(marketUpdate.sparklineUpdate);
        if (sparkline) {
            return {
                market,
                sparkline
            };
        }
    }
    return null;
}
function orderBookSnapshotFromProto(orderBookSnapshot) {
    if (orderBookSnapshot.seqNum === null ||
        orderBookSnapshot.seqNum === undefined) {
        return null;
    }
    return {
        seqNum: orderBookSnapshot.seqNum,
        bids: publicOrdersFromProto(orderBookSnapshot.bids),
        asks: publicOrdersFromProto(orderBookSnapshot.asks)
    };
}
function orderBookDeltaFromProto(orderBookDelta) {
    if (!orderBookDelta.seqNum) {
        return null;
    }
    let bidSet = [];
    let bidRemove = [];
    if (orderBookDelta.bids) {
        bidSet = publicOrdersFromProto(orderBookDelta.bids.set);
        if (orderBookDelta.bids.removeStr) {
            bidRemove = orderBookDelta.bids.removeStr;
        }
    }
    let askSet = [];
    let askRemove = [];
    if (orderBookDelta.asks) {
        askSet = publicOrdersFromProto(orderBookDelta.asks.set);
        if (orderBookDelta.asks.removeStr) {
            askRemove = orderBookDelta.asks.removeStr;
        }
    }
    return {
        seqNum: orderBookDelta.seqNum,
        bids: {
            set: bidSet,
            remove: bidRemove
        },
        asks: {
            set: askSet,
            remove: askRemove
        }
    };
}
function orderBookSpreadFromProto(orderBookSpread) {
    if (!orderBookSpread.timestamp ||
        !orderBookSpread.bid ||
        !orderBookSpread.ask) {
        return null;
    }
    const bid = publicOrderFromProto(orderBookSpread.bid);
    if (!bid) {
        return null;
    }
    const ask = publicOrderFromProto(orderBookSpread.ask);
    if (!ask) {
        return null;
    }
    return {
        timestamp: helpers_1.getDateFromSecs(orderBookSpread.timestamp),
        bid,
        ask
    };
}
// TODO test this
function publicTradesFromProto(tradesUpdate) {
    if (!tradesUpdate.trades) {
        return null;
    }
    const publicTrades = [];
    tradesUpdate.trades.forEach(trade => {
        if (!trade || !trade.externalId || !trade.priceStr || !trade.amountStr) {
            return;
        }
        let timestamp;
        if (trade.timestampNano && trade.timestampNano > 0) {
            timestamp = helpers_1.getDateFromNs(trade.timestampNano);
        }
        else if (trade.timestampMillis && trade.timestampMillis > 0) {
            timestamp = helpers_1.getDateFromMs(trade.timestampMillis);
        }
        else if (trade.timestamp && trade.timestamp > 0) {
            timestamp = helpers_1.getDateFromSecs(trade.timestamp);
        }
        else {
            return;
        }
        publicTrades.push({
            externalID: trade.externalId,
            timestamp,
            price: trade.priceStr,
            amount: trade.amountStr
        });
    });
    return publicTrades;
}
function privateTradeFromProto(trade) {
    if (trade.externalId == null ||
        trade.orderId == null ||
        !trade.priceString ||
        !trade.amountString) {
        return null;
    }
    let d;
    if (trade.timeMillis && trade.timeMillis > 0) {
        d = helpers_1.getDateFromMs(trade.timeMillis);
    }
    else if (trade.time != null) {
        d = helpers_1.getDateFromSecs(trade.time);
    }
    else {
        return null;
    }
    const side = sideFromProto(trade.side);
    if (!side) {
        return null;
    }
    return {
        id: trade.externalId,
        orderID: trade.orderId,
        timestamp: d,
        side,
        price: trade.priceString,
        amount: trade.amountString
    };
}
function privatePositionFromProto(position) {
    if (position.id == null ||
        !position.time ||
        !position.avgPriceString ||
        !position.amountOpenString ||
        !position.amountClosedString ||
        !position.orderIds ||
        !position.tradeIds) {
        return null;
    }
    const side = sideFromProto(position.side);
    if (!side) {
        return null;
    }
    return {
        id: position.id,
        timestamp: helpers_1.getDateFromSecs(position.time),
        side,
        avgPrice: position.avgPriceString,
        amountOpen: position.amountOpenString,
        amountClosed: position.amountClosedString,
        orderIDs: position.orderIds,
        tradeIDs: position.tradeIds
    };
}
function balancesFromProto(balances) {
    if (!balances.fundingType || !balances.balances) {
        return null;
    }
    const returnBalances = {
        fundingType: balances.fundingType,
        balances: []
    };
    balances.balances.forEach(balanceProto => {
        const balance = balanceFromProto(balanceProto);
        if (!balance) {
            return;
        }
        returnBalances.balances.push(balance);
    });
    return returnBalances;
}
function balanceFromProto(balance) {
    if (!balance.currency || !balance.amountString) {
        return null;
    }
    return {
        currency: balance.currency,
        amount: balance.amountString
    };
}
function sideFromProto(side) {
    if (!side) {
        return null;
    }
    if (orderSides[side]) {
        return orderSides[side];
    }
    return null;
}
function intervalsFromProto(intervalsUpdate) {
    if (!intervalsUpdate.intervals) {
        return null;
    }
    const intervals = [];
    intervalsUpdate.intervals.forEach(intervalProto => {
        const i = intervalFromProto(intervalProto);
        if (i) {
            intervals.push(i);
        }
    });
    return intervals;
}
function intervalFromProto(intervalUpdate) {
    if (!intervalUpdate.period ||
        !intervalUpdate.closetime ||
        !intervalUpdate.ohlc ||
        !intervalUpdate.ohlc.openStr ||
        !intervalUpdate.ohlc.highStr ||
        !intervalUpdate.ohlc.lowStr ||
        !intervalUpdate.ohlc.closeStr ||
        !intervalUpdate.volumeBaseStr ||
        !intervalUpdate.volumeQuoteStr) {
        return null;
    }
    const period = getPeriod(intervalUpdate.period);
    if (!period) {
        return null;
    }
    const ohlc = {
        open: intervalUpdate.ohlc.openStr,
        high: intervalUpdate.ohlc.highStr,
        low: intervalUpdate.ohlc.lowStr,
        close: intervalUpdate.ohlc.closeStr
    };
    return {
        period,
        ohlc,
        closeTime: new Date(helpers_1.getNumber(intervalUpdate.closetime) * 1000),
        volumeBase: intervalUpdate.volumeBaseStr,
        volumeQuote: intervalUpdate.volumeQuoteStr
    };
}
function summaryFromProto(summaryUpdate) {
    if (!summaryUpdate.lastStr ||
        !summaryUpdate.highStr ||
        !summaryUpdate.lowStr ||
        !summaryUpdate.volumeBaseStr ||
        !summaryUpdate.volumeQuoteStr ||
        !summaryUpdate.changeAbsoluteStr ||
        !summaryUpdate.changePercentStr ||
        !summaryUpdate.numTrades) {
        return null;
    }
    return {
        last: summaryUpdate.lastStr,
        high: summaryUpdate.highStr,
        low: summaryUpdate.lowStr,
        volumeBase: summaryUpdate.volumeBaseStr,
        volumeQuote: summaryUpdate.volumeQuoteStr,
        changeAbsolute: summaryUpdate.changeAbsoluteStr,
        changePercent: summaryUpdate.changePercentStr,
        numTrades: summaryUpdate.numTrades
    };
}
function sparklineFromProto(sparklineUpdate) {
    if (!sparklineUpdate.time || !sparklineUpdate.priceStr) {
        return null;
    }
    return {
        timestamp: helpers_1.getDateFromSecs(sparklineUpdate.time),
        price: sparklineUpdate.priceStr
    };
}
function publicOrdersFromProto(publicOrders) {
    const orders = [];
    if (publicOrders) {
        publicOrders.forEach(order => {
            const publicOrder = publicOrderFromProto(order);
            if (publicOrder !== null) {
                orders.push(publicOrder);
            }
        });
    }
    return orders;
}
function publicOrderFromProto(publicOrder) {
    if (!publicOrder.priceStr || !publicOrder.amountStr) {
        return null;
    }
    return {
        price: publicOrder.priceStr,
        amount: publicOrder.amountStr
    };
}
function placeOrderOptToProto(orderOpts) {
    if (!validateOrderSideProto(orderOpts.side)) {
        throw new Error(`Invalid order parameters: side=${orderOpts.side}`);
    }
    if (!validateOrderTypeProto(orderOpts.type)) {
        throw new Error(`Invalid order parameters: type=${orderOpts.type}`);
    }
    if (orderOpts.price && !checkMonetaryValue(orderOpts.price)) {
        throw new Error(`Invalid order parameters: price=${orderOpts.price}`);
    }
    if (!checkMonetaryValue(orderOpts.amount)) {
        throw new Error(`Invalid order parameters: amount=${orderOpts.amount}`);
    }
    let type = "limit";
    if (orderOpts.type !== undefined) {
        type = orderOpts.type;
    }
    const fundingType = "spot";
    // if (typeof orderOpts.fundingType === "number") {
    //   fundingType = fundingTypes[orderOpts.fundingType];
    // }
    const leverage = null;
    // if (orderOpts.leverage !== undefined) {
    //   leverage = orderOpts.leverage;
    // }
    const expireTime = null;
    // if (orderOpts.expireTime !== undefined) {
    //   expireTime = orderOpts.expireTime.getTime();
    // }
    const priceParams = [
        {
            valueString: String(orderOpts.price),
            type: proto_1.ProtobufBroker.PrivateOrder.PriceParamType.AbsoluteValue
        }
    ];
    return {
        side: orderSideToProto[orderOpts.side],
        type: orderTypeToProto[type],
        fundingType: fundingTypeToProto[fundingType],
        priceParams,
        amountParamString: String(orderOpts.amount),
        leverage,
        expireTime
    };
}
function marketFromProto(market) {
    if (!market.marketId || !market.exchangeId || !market.currencyPairId) {
        return null;
    }
    return {
        id: helpers_1.getString(market.marketId),
        exchangeID: helpers_1.getString(market.exchangeId),
        currencyPairID: helpers_1.getString(market.currencyPairId)
    };
}
function getPeriod(period) {
    if (periodFromInt[period]) {
        return periodFromInt[period];
    }
    return null;
}
function keyToStreamSubscription(key) {
    return proto_1.ProtobufClient.ClientSubscription.create({
        streamSubscription: proto_1.ProtobufClient.StreamSubscription.create({
            resource: key
        })
    });
}
function tradeSubscriptionToProto(tradeSubscription) {
    let auth = null;
    if (tradeSubscription.auth) {
        auth = proto_1.ProtobufClient.TradeSessionAuth.create({
            apiKey: tradeSubscription.auth.apiKey,
            apiSecret: tradeSubscription.auth.apiSecret,
            customerId: tradeSubscription.auth.customerID,
            keyPassphrase: tradeSubscription.auth.keyPassphrase
        });
    }
    return proto_1.ProtobufClient.ClientSubscription.create({
        tradeSubscription: proto_1.ProtobufClient.TradeSubscription.create({
            marketId: tradeSubscription.marketID,
            auth
        })
    });
}
function keyFromClientSubscription(sub) {
    if (sub.streamSubscription && sub.streamSubscription.resource) {
        return sub.streamSubscription.resource;
    }
    if (sub.tradeSubscription && sub.tradeSubscription.marketId) {
        return sub.tradeSubscription.marketId;
    }
    return null;
}
function subscriptionResultFromProto(subResult) {
    if (subResult.failed === null && subResult.subscriptions === null) {
        return null;
    }
    const subscriptions = [];
    const failed = [];
    if (subResult.failed instanceof Array) {
        subResult.failed.forEach(e => {
            if (typeof e.error !== "string" ||
                !(e.subscription instanceof proto_1.ProtobufClient.ClientSubscription)) {
                return null;
            }
            const sub = keyFromClientSubscription(e.subscription);
            if (sub === null) {
                return null;
            }
            failed.push({
                error: e.error,
                subscription: sub
            });
        });
    }
    return {
        subscriptions,
        failed
    };
}
function validateOrderTypeProto(t) {
    return typeof orderSideToProto[t] === "number";
}
function validateOrderSideProto(s) {
    return typeof fundingTypeToProto[s] === "number";
}
function checkMonetaryValue(n) {
    return n > 0;
}
const proto = {
    balancesFromProto,
    pairUpdateFromProto,
    marketUpdateFromProto,
    periodFromInt,
    orderSides,
    placeOrderOptToProto,
    privateOrderFromProto,
    privateTradeFromProto,
    privatePositionFromProto,
    keyToStreamSubscription,
    tradeSubscriptionToProto,
    subscriptionResultFromProto
};
exports.default = proto;
