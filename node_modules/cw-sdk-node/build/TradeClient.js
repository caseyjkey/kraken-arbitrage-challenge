"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid/v4");
const constants_1 = require("./constants");
const credentials_1 = require("./credentials");
const proto_1 = require("./modules/proto");
const SessionTracker_1 = require("./SessionTracker");
const helpers_1 = require("./util/helpers");
const logger_1 = require("./util/logger");
const proto_2 = require("./util/proto");
const WebSocketClient_1 = require("./WebSocketClient");
// The number of recent trades kept locally in cache
const tradeCacheLimit = 1000;
// Requests to the trade service time out after 5s
const requestTimeout = 5000;
class TradeClient extends WebSocketClient_1.default {
    constructor(opts) {
        logger_1.default.setLevel(opts.logLevel);
        opts = credentials_1.loadTradeCredentials(opts);
        super(opts);
        if (!(opts.tradeSubscriptions instanceof Array) ||
            opts.tradeSubscriptions.length === 0) {
            throw new Error("Missing parameter: tradeSubscriptions");
        }
        // Keep track of subscriptions for reconnecting
        opts.tradeSubscriptions.forEach(ts => {
            this.subscriptions[ts.marketID] = proto_2.default.tradeSubscriptionToProto(ts);
        });
        this.session = new SessionTracker_1.default(opts.tradeSubscriptions);
        this.session.on("ready", () => {
            logger_1.default.debug("trading ready");
        });
        this.onDisconnect(() => {
            logger_1.default.debug("disconnected: resetting session");
            this.session.reset();
        });
        this.on(constants_1.EventWSData, (data) => {
            try {
                this.brokerMessageHandler(proto_1.ProtobufBroker.BrokerUpdateMessage.decode(data));
            }
            catch (e) {
                this.error("Failed to deserialize ProtobufBroker message");
            }
        });
        this.orders = {};
        this.trades = {};
        this.positions = {};
        // this.balances = [];
        logger_1.default.debug("%o", this);
    }
    onReady(fn) {
        this.session.on("ready", () => {
            fn();
        });
    }
    onOrdersUpdate(fn) {
        this.on(constants_1.EventOrdersUpdate, orders => fn(orders));
    }
    onTradesUpdate(fn) {
        this.on(constants_1.EventTradesUpdate, trades => fn(trades));
    }
    onPositionsUpdate(fn) {
        this.on(constants_1.EventPositionsUpdate, positions => fn(positions));
    }
    placeOrder(opts) {
        logger_1.default.debug("place order request %o", opts);
        if (!this.session.isReady()) {
            throw errNotInitialized;
        }
        const startTime = new Date();
        return new Promise((resolve, reject) => {
            const order = proto_2.default.placeOrderOptToProto(opts);
            logger_1.default.debug("place order request %o", order);
            this.makeRequest(opts.marketID, proto_1.ProtobufBroker.PlaceOrderRequest.create({
                order
            }))
                .then(response => {
                if (!response.placeOrderResult || !response.placeOrderResult.order) {
                    const msg = "Place order failed: bad response";
                    logger_1.default.debug(msg);
                    reject(new Error(msg));
                    return;
                }
                const po = proto_2.default.privateOrderFromProto(response.placeOrderResult.order);
                if (!po) {
                    logger_1.default.debug("Failed to serialize order result %o", response.placeOrderResult.order);
                    // TODO fix
                    process.exit(1);
                    reject(new Error("Place order failed: bad response"));
                    return;
                }
                const endTime = new Date();
                logger_1.default.debug("order placed", `${endTime.getTime() - startTime.getTime()}s`);
                resolve(po);
            })
                .catch(e => {
                reject(e);
            });
        });
    }
    cancelOrder(opts) {
        return new Promise((resolve, reject) => {
            if (typeof opts.orderID !== "string" || opts.orderID === "") {
                throw new Error(`Order ID is invalid: ${opts.orderID}`);
            }
            this.makeRequest(opts.marketID, proto_1.ProtobufBroker.CancelOrderRequest.create({
                orderId: opts.orderID
            }))
                .then(response => {
                if (!response.cancelOrderResult ||
                    response.cancelOrderResult.orderId === null) {
                    reject(errBadResponse);
                    return;
                }
                resolve();
            })
                .catch(e => reject(e));
        });
    }
    makeRequest(marketID, request) {
        const requestID = uuid();
        let brokerRequest;
        if (request instanceof proto_1.ProtobufBroker.PlaceOrderRequest) {
            brokerRequest = proto_1.ProtobufBroker.BrokerRequest.create({
                id: requestID,
                marketId: Number(marketID),
                placeOrderRequest: request
            });
        }
        else {
            brokerRequest = proto_1.ProtobufBroker.BrokerRequest.create({
                id: requestID,
                marketId: Number(marketID),
                cancelOrderRequest: request
            });
        }
        this.send(proto_1.ProtobufBroker.BrokerRequest.encode(brokerRequest).finish());
        return new Promise((resolve, reject) => {
            const timeoutTimer = setTimeout(() => {
                reject();
            }, requestTimeout);
            this.once(requestID, response => {
                clearTimeout(timeoutTimer);
                if (response.error !== 0) {
                    reject(`Server response: ${response.message}`);
                }
                else {
                    resolve(response);
                }
            });
        });
    }
    brokerMessageHandler(message) {
        const marketID = helpers_1.getString(message.marketId);
        switch (message.Update) {
            case "authenticationResult":
                this.emit(constants_1.EventWSAuthResult, message.authenticationResult);
                break;
            case "ordersUpdate":
                if (message.ordersUpdate) {
                    this.ordersUpdateHandler(marketID, message.ordersUpdate);
                }
                break;
            case "tradesUpdate":
                if (message.tradesUpdate) {
                    this.tradesUpdateHandler(marketID, message.tradesUpdate);
                }
                break;
            case "balancesUpdate":
                logger_1.default.debug("balance update %o", JSON.stringify(message));
                // if (message.balancesUpdate) {
                //   this.balancesUpdateHandler(marketID, message.balancesUpdate);
                // }
                break;
            case "positionsUpdate":
                if (message.positionsUpdate) {
                    this.positionsUpdateHandler(marketID, message.positionsUpdate);
                }
                break;
            case "subscriptionResult":
                if (message.subscriptionResult) {
                    this.subscriptionResultHandler(message.subscriptionResult);
                }
                break;
            case "sessionStatusUpdate":
                if (message.sessionStatusUpdate) {
                    this.sessionStatusUpdateHandler(marketID, message.sessionStatusUpdate);
                }
                break;
            case "requestResolutionUpdate":
                if (message.requestResolutionUpdate) {
                    this.requestResolutionUpdateHandler(message.requestResolutionUpdate);
                }
                break;
            default:
            // unsupported type; no-op
        }
    }
    ordersUpdateHandler(marketID, ordersUpdate) {
        logger_1.default.debug("orders update");
        if (!ordersUpdate.orders) {
            return;
        }
        const newOrders = [];
        ordersUpdate.orders.forEach(o => {
            const order = proto_2.default.privateOrderFromProto(o);
            if (order != null) {
                newOrders.push(order);
            }
        });
        this.session.setModuleReady(marketID, "orders");
        this.orders[marketID] = newOrders;
        this.emit(constants_1.EventOrdersUpdate, newOrders);
    }
    tradesUpdateHandler(marketID, tradesUpdate) {
        logger_1.default.debug("trades update");
        if (!tradesUpdate.trades) {
            return;
        }
        const newTrades = [];
        tradesUpdate.trades.forEach(tradeProto => {
            const trade = proto_2.default.privateTradeFromProto(tradeProto);
            if (trade) {
                newTrades.push(trade);
            }
        });
        if (!this.trades[marketID]) {
            this.trades[marketID] = [];
        }
        // Add new trades to old trades
        this.trades[marketID] = this.trades[marketID].concat(newTrades);
        // Trim cache if it's over the limit
        if (this.trades[marketID].length > tradeCacheLimit) {
            this.trades[marketID] = this.trades[marketID].slice(0, tradeCacheLimit);
        }
        this.session.setModuleReady(marketID, "trades");
        this.emit(constants_1.EventTradesUpdate, newTrades);
    }
    // private balancesUpdateHandler(
    //   marketID: string,
    //   balancesUpdate: ProtobufBroker.IBalancesUpdate
    // ) {
    //   if (!balancesUpdate.balances) {
    //     return;
    //   }
    //   // Each balance can apply to multiple markets, so we find the balances index first
    //   let balancesIndex = -1;
    //   for (let i = 0; i < this.balances.length; i++) {
    //     for (const j of this.balances[i].marketIDs) {
    //       if (j === marketID) {
    //         balancesIndex = i;
    //         break;
    //       }
    //     }
    //     if (balancesIndex > -1) {
    //       break;
    //     }
    //   }
    //   if (balancesIndex === -1) {
    //     const exchangeBalances: ExchangeBalances = {
    //       marketIDs: [marketID],
    //       spot: [],
    //       margin: []
    //     };
    //   }
    //   balancesUpdate.balances.forEach(balancesProto => {
    //     const balance = proto.balancesFromProto(balancesProto);
    //     if (!balance) {
    //       return;
    //     }
    //   });
    //   this.session.setModuleReady(marketID, "balances");
    //   logger.debug("balances update");
    //   // TODO update balances cache
    //   // TODO emit exchange balances
    //   // this.emit(EventBalancesUpdate, exchangeBalances);
    // }
    positionsUpdateHandler(marketID, positionsUpdate) {
        logger_1.default.debug("positions update");
        if (!positionsUpdate.positions) {
            return;
        }
        const newPositions = [];
        positionsUpdate.positions.forEach(positionProto => {
            const position = proto_2.default.privatePositionFromProto(positionProto);
            if (!position) {
                return;
            }
            newPositions.push(position);
        });
        this.session.setModuleReady(marketID, "positions");
        this.positions[marketID] = newPositions;
        this.emit(constants_1.EventPositionsUpdate, newPositions);
    }
    subscriptionResultHandler(subResult) {
        if (subResult.failed instanceof Array) {
            subResult.failed.forEach(e => {
                let keyStr = "";
                if (e.key) {
                    keyStr = ` for "${e.key}"`;
                }
                this.error(`trading session failed${keyStr}: ${e.error}`);
            });
        }
    }
    sessionStatusUpdateHandler(marketID, sessionStatusUpdate) {
        if (sessionStatusUpdate.initialized === true) {
            this.session.setModuleReady(marketID, "placeOrder");
        }
    }
    requestResolutionUpdateHandler(requestResolution) {
        if (requestResolution.id != null) {
            this.emit(requestResolution.id, requestResolution);
        }
    }
}
exports.TradeClient = TradeClient;
const errNotInitialized = new Error("Trading is not yet initialized. Did you wait for onReady()?");
const errBadResponse = new Error("Bad response");
